-- V2: pgvector extension + embeddings storage (KnowGauge)

-- 1) Enable pgvector
CREATE EXTENSION IF NOT EXISTS vector;

-- 2) Embeddings table (references relational chunk table)
CREATE TABLE chunk_embeddings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tenant_id BIGINT NOT NULL,
    topic_id BIGINT NOT NULL,
    document_id BIGINT NOT NULL,
    document_version INTEGER NOT NULL DEFAULT 1,
    section_id BIGINT,
    chunk_id BIGINT NOT NULL,
    -- drift detection: should match document_chunks.checksum
    chunk_checksum VARCHAR(64) NOT NULL,
    embedding vector(1536) NOT NULL,
    embedding_model VARCHAR(100) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT NOT NULL,
    updated_by BIGINT NOT NULL,

    CONSTRAINT fk_chunk_embeddings_chunk
        FOREIGN KEY (chunk_id) REFERENCES document_chunks(id) ON DELETE CASCADE,

    CONSTRAINT uk_chunk_embeddings_chunk_model
        UNIQUE (chunk_id, embedding_model)
);

-- 3) Useful filtering indexes
-- Metadata filter indexes (so you can search embeddings DB alone)
CREATE INDEX idx_chunk_embeddings_docver
    ON chunk_embeddings(tenant_id, document_id, document_version);

CREATE INDEX idx_chunk_embeddings_topic
    ON chunk_embeddings(tenant_id, topic_id);

CREATE INDEX idx_chunk_embeddings_model
    ON chunk_embeddings(tenant_id, embedding_model);

CREATE INDEX idx_chunk_embeddings_chunk_id
    ON chunk_embeddings(tenant_id, chunk_id);

-- 4) Vector similarity index (cosine distance)
-- NOTE:
-- - ivfflat requires ANALYZE and performs best with enough rows.
-- - If your table is tiny early on, this index isnâ€™t necessary (but is fine).
CREATE INDEX idx_chunk_embeddings_embedding
    ON chunk_embeddings
    USING ivfflat (embedding vector_cosine_ops)
    WITH (lists = 100);
